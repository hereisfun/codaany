# å¦‚ä½•æ„å»ºä¸€ä¸ªç±» Coda äº§å“ - å®Œæ•´æ¶æ„æŒ‡å—

## ç›®å½•
- [1. äº§å“å®šä½ä¸æŠ€æœ¯é€‰å‹](#1-äº§å“å®šä½ä¸æŠ€æœ¯é€‰å‹)
- [2. åˆ†å±‚æ¶æ„è®¾è®¡](#2-åˆ†å±‚æ¶æ„è®¾è®¡)
- [3. æ¸²æŸ“å±‚å®ç°æ–¹æ¡ˆ](#3-æ¸²æŸ“å±‚å®ç°æ–¹æ¡ˆ)
- [4. æ•°æ®å±‚å®ç°æ–¹æ¡ˆ](#4-æ•°æ®å±‚å®ç°æ–¹æ¡ˆ)
- [5. ååŒå±‚å®ç°æ–¹æ¡ˆ](#5-ååŒå±‚å®ç°æ–¹æ¡ˆ)
- [6. å…¬å¼å±‚å®ç°æ–¹æ¡ˆ](#6-å…¬å¼å±‚å®ç°æ–¹æ¡ˆ)
- [7. å¼€å‘è·¯çº¿å›¾](#7-å¼€å‘è·¯çº¿å›¾)
- [8. æŠ€æœ¯éš¾ç‚¹ä¸è§£å†³æ–¹æ¡ˆ](#8-æŠ€æœ¯éš¾ç‚¹ä¸è§£å†³æ–¹æ¡ˆ)

---

## 1. äº§å“å®šä½ä¸æŠ€æœ¯é€‰å‹

### 1.1 äº§å“å®šä½

**æ ¸å¿ƒèƒ½åŠ›**ï¼š
- ğŸ“ å¯Œæ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆæ–‡æ¡£ã€è¡¨æ ¼ã€ä»£ç å—ç­‰ï¼‰
- ğŸ“Š å¼ºå¤§çš„è¡¨æ ¼ç³»ç»Ÿï¼ˆç±»ä¼¼ Airtableï¼‰
- ğŸ”¢ å…¬å¼å¼•æ“ï¼ˆç±»ä¼¼ Excelï¼‰
- ğŸ¤ å®æ—¶ååŒç¼–è¾‘
- ğŸ”Œ API å’Œé›†æˆèƒ½åŠ›

**ç›®æ ‡ç”¨æˆ·**ï¼š
- å›¢é˜Ÿåä½œåœºæ™¯
- çŸ¥è¯†ç®¡ç†å’Œæ–‡æ¡£ç¼–å†™
- æ•°æ®ç®¡ç†å’Œåˆ†æ
- å·¥ä½œæµè‡ªåŠ¨åŒ–

### 1.2 æŠ€æœ¯é€‰å‹

| å±‚æ¬¡ | æŠ€æœ¯æ ˆ | ç†ç”± |
|------|--------|------|
| **å‰ç«¯æ¡†æ¶** | React 18+ | æˆç†Ÿç¨³å®šï¼Œç”Ÿæ€ä¸°å¯Œï¼ŒHooks ç®€åŒ–çŠ¶æ€ç®¡ç† |
| **å¯Œæ–‡æœ¬å¼•æ“** | Slate.js | å¯å®šåˆ¶æ€§å¼ºï¼Œé€‚åˆå¤æ‚æ–‡æ¡£ç¼–è¾‘ |
| **çŠ¶æ€ç®¡ç†** | Zustand / Jotai | è½»é‡çº§ï¼Œé€‚åˆå¤§è§„æ¨¡åº”ç”¨ |
| **æ ·å¼æ–¹æ¡ˆ** | Tailwind CSS + CSS Modules | å¿«é€Ÿå¼€å‘ï¼Œæ ·å¼éš”ç¦» |
| **æ„å»ºå·¥å…·** | Vite | å¿«é€Ÿå†·å¯åŠ¨ï¼ŒHMR ä½“éªŒå¥½ |
| **ç±»å‹æ£€æŸ¥** | TypeScript | ç±»å‹å®‰å…¨ï¼Œå‡å°‘è¿è¡Œæ—¶é”™è¯¯ |
| **åç«¯æ¡†æ¶** | Node.js + Fastify / Go | é«˜æ€§èƒ½ï¼Œæ”¯æŒ WebSocket |
| **æ•°æ®åº“** | PostgreSQL + Redis | å…³ç³»æ•°æ® + ç¼“å­˜ |
| **å®æ—¶é€šä¿¡** | WebSocket (Socket.io) | åŒå‘é€šä¿¡ï¼Œè‡ªåŠ¨é‡è¿ |
| **å­˜å‚¨** | IndexedDB (Dexie.js) | æµè§ˆå™¨æœ¬åœ°å­˜å‚¨ |
| **å…¬å¼å¼•æ“** | è‡ªç ” + Math.js | çµæ´»æ‰©å±•ï¼Œæ”¯æŒè‡ªå®šä¹‰å‡½æ•° |
| **éƒ¨ç½²** | Docker + Kubernetes | å®¹å™¨åŒ–ï¼Œæ˜“äºæ‰©å±• |

### 1.3 æ•´ä½“æ¶æ„å›¾

```mermaid
graph TB
    subgraph å®¢æˆ·ç«¯
        A[React App]
        B[Slate Editor]
        C[State Management]
        D[IndexedDB]
        E[Web Worker]
    end
    
    subgraph APIå±‚
        F[REST API]
        G[WebSocket Server]
        H[Authentication]
    end
    
    subgraph ä¸šåŠ¡å±‚
        I[Document Service]
        J[Collaboration Service]
        K[Formula Service]
        L[Permission Service]
    end
    
    subgraph æ•°æ®å±‚
        M[PostgreSQL]
        N[Redis]
        O[Object Storage]
    end
    
    A --> B
    A --> C
    A --> D
    A --> E
    
    A <--> F
    A <--> G
    F --> H
    G --> H
    
    F --> I
    F --> J
    F --> K
    F --> L
    G --> J
    
    I --> M
    J --> N
    K --> N
    L --> M
    I --> O
```

---

## 2. åˆ†å±‚æ¶æ„è®¾è®¡

### 2.1 å‰ç«¯åˆ†å±‚

```
src/
â”œâ”€â”€ presentation/          # è¡¨ç°å±‚
â”‚   â”œâ”€â”€ components/        # React ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ editor/       # ç¼–è¾‘å™¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ table/        # è¡¨æ ¼ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ formula/      # å…¬å¼ç»„ä»¶
â”‚   â”‚   â””â”€â”€ common/       # é€šç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ hooks/            # è‡ªå®šä¹‰ Hooks
â”‚   â””â”€â”€ pages/            # é¡µé¢ç»„ä»¶
â”‚
â”œâ”€â”€ application/          # åº”ç”¨å±‚
â”‚   â”œâ”€â”€ stores/          # çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ services/        # ä¸šåŠ¡æœåŠ¡
â”‚   â””â”€â”€ commands/        # å‘½ä»¤æ¨¡å¼
â”‚
â”œâ”€â”€ domain/              # é¢†åŸŸå±‚
â”‚   â”œâ”€â”€ models/         # é¢†åŸŸæ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ document.ts
â”‚   â”‚   â”œâ”€â”€ grid.ts
â”‚   â”‚   â”œâ”€â”€ formula.ts
â”‚   â”‚   â””â”€â”€ operation.ts
â”‚   â”œâ”€â”€ repositories/   # ä»“å‚¨æ¥å£
â”‚   â””â”€â”€ events/         # é¢†åŸŸäº‹ä»¶
â”‚
â”œâ”€â”€ infrastructure/      # åŸºç¡€è®¾æ–½å±‚
â”‚   â”œâ”€â”€ api/           # API å®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ storage/       # æœ¬åœ°å­˜å‚¨
â”‚   â”œâ”€â”€ websocket/     # WebSocket å®¢æˆ·ç«¯
â”‚   â””â”€â”€ workers/       # Web Workers
â”‚
â””â”€â”€ shared/             # å…±äº«å±‚
    â”œâ”€â”€ types/         # ç±»å‹å®šä¹‰
    â”œâ”€â”€ utils/         # å·¥å…·å‡½æ•°
    â””â”€â”€ constants/     # å¸¸é‡
```

### 2.2 åç«¯åˆ†å±‚

```
server/
â”œâ”€â”€ api/                # API å±‚
â”‚   â”œâ”€â”€ rest/          # REST API
â”‚   â”œâ”€â”€ websocket/     # WebSocket
â”‚   â””â”€â”€ graphql/       # GraphQL (å¯é€‰)
â”‚
â”œâ”€â”€ application/        # åº”ç”¨å±‚
â”‚   â”œâ”€â”€ services/      # åº”ç”¨æœåŠ¡
â”‚   â”œâ”€â”€ dtos/          # æ•°æ®ä¼ è¾“å¯¹è±¡
â”‚   â””â”€â”€ mappers/       # å¯¹è±¡æ˜ å°„å™¨
â”‚
â”œâ”€â”€ domain/            # é¢†åŸŸå±‚
â”‚   â”œâ”€â”€ entities/     # å®ä½“
â”‚   â”œâ”€â”€ aggregates/   # èšåˆæ ¹
â”‚   â”œâ”€â”€ value-objects/ # å€¼å¯¹è±¡
â”‚   â””â”€â”€ events/       # é¢†åŸŸäº‹ä»¶
â”‚
â”œâ”€â”€ infrastructure/    # åŸºç¡€è®¾æ–½å±‚
â”‚   â”œâ”€â”€ database/     # æ•°æ®åº“
â”‚   â”œâ”€â”€ cache/        # ç¼“å­˜
â”‚   â”œâ”€â”€ storage/      # å¯¹è±¡å­˜å‚¨
â”‚   â””â”€â”€ messaging/    # æ¶ˆæ¯é˜Ÿåˆ—
â”‚
â””â”€â”€ shared/           # å…±äº«å±‚
    â”œâ”€â”€ errors/       # é”™è¯¯å¤„ç†
    â”œâ”€â”€ logger/       # æ—¥å¿—
    â””â”€â”€ config/       # é…ç½®
```

---

## 3. æ¸²æŸ“å±‚å®ç°æ–¹æ¡ˆ

### 3.1 Slate é›†æˆ

#### Step 1: å®‰è£…ä¾èµ–

```bash
npm install slate slate-react slate-history
npm install @types/slate @types/slate-react -D
```

#### Step 2: åˆ›å»º Slate ç¼–è¾‘å™¨

```typescript
// src/domain/models/editor.ts
import { createEditor, Descendant } from 'slate';
import { withReact } from 'slate-react';
import { withHistory } from 'slate-history';

/**
 * åˆ›å»ºç¼–è¾‘å™¨å®ä¾‹
 */
export function createSlateEditor() {
  return withHistory(withReact(createEditor()));
}

/**
 * åˆå§‹å€¼
 */
export const initialValue: Descendant[] = [
  {
    type: 'paragraph',
    children: [{ text: '' }]
  }
];
```

#### Step 3: ç¼–è¾‘å™¨ç»„ä»¶

```typescript
// src/presentation/components/editor/SlateEditor.tsx
import React, { useMemo, useCallback } from 'react';
import { Slate, Editable, RenderElementProps, RenderLeafProps } from 'slate-react';
import { createSlateEditor } from '@/domain/models/editor';

export function SlateEditor({ value, onChange }) {
  const editor = useMemo(() => createSlateEditor(), []);
  
  const renderElement = useCallback((props: RenderElementProps) => {
    switch (props.element.type) {
      case 'paragraph':
        return <p {...props.attributes}>{props.children}</p>;
      case 'heading1':
        return <h1 {...props.attributes}>{props.children}</h1>;
      case 'table':
        return <TableBlock {...props} />;
      default:
        return <div {...props.attributes}>{props.children}</div>;
    }
  }, []);
  
  const renderLeaf = useCallback((props: RenderLeafProps) => {
    let { children } = props;
    
    if (props.leaf.bold) {
      children = <strong>{children}</strong>;
    }
    
    if (props.leaf.italic) {
      children = <em>{children}</em>;
    }
    
    return <span {...props.attributes}>{children}</span>;
  }, []);
  
  return (
    <Slate editor={editor} value={value} onChange={onChange}>
      <Editable
        renderElement={renderElement}
        renderLeaf={renderLeaf}
        placeholder="å¼€å§‹è¾“å…¥..."
      />
    </Slate>
  );
}
```

### 3.2 è™šæ‹ŸåŒ–å®ç°

```bash
npm install react-window react-window-infinite-loader
```

```typescript
// src/presentation/components/table/VirtualizedTable.tsx
import React from 'react';
import { FixedSizeGrid } from 'react-window';

interface VirtualizedTableProps {
  rows: Row[];
  columns: Column[];
  rowHeight: number;
  columnWidth: number;
}

export function VirtualizedTable({
  rows,
  columns,
  rowHeight,
  columnWidth
}: VirtualizedTableProps) {
  const Cell = ({ columnIndex, rowIndex, style }) => {
    const row = rows[rowIndex];
    const column = columns[columnIndex];
    const value = row.values.get(column.id);
    
    return (
      <div style={style} className="table-cell">
        {value?.displayValue}
      </div>
    );
  };
  
  return (
    <FixedSizeGrid
      columnCount={columns.length}
      columnWidth={columnWidth}
      height={600}
      rowCount={rows.length}
      rowHeight={rowHeight}
      width={1000}
    >
      {Cell}
    </FixedSizeGrid>
  );
}
```

### 3.3 æ€§èƒ½ä¼˜åŒ–

```typescript
// src/shared/utils/performance.ts

/**
 * é˜²æŠ–
 */
export function debounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timer: number | null = null;
  
  return (...args) => {
    if (timer) clearTimeout(timer);
    
    timer = window.setTimeout(() => {
      fn(...args);
    }, delay);
  };
}

/**
 * èŠ‚æµ
 */
export function throttle<T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let lastCall = 0;
  
  return (...args) => {
    const now = Date.now();
    
    if (now - lastCall >= delay) {
      lastCall = now;
      fn(...args);
    }
  };
}

/**
 * RAF æ‰¹å¤„ç†
 */
export class RAFBatcher {
  private pending = new Set<() => void>();
  private scheduled = false;
  
  add(fn: () => void): void {
    this.pending.add(fn);
    
    if (!this.scheduled) {
      this.scheduled = true;
      requestAnimationFrame(() => this.flush());
    }
  }
  
  private flush(): void {
    for (const fn of this.pending) {
      fn();
    }
    
    this.pending.clear();
    this.scheduled = false;
  }
}
```

---

## 4. æ•°æ®å±‚å®ç°æ–¹æ¡ˆ

### 4.1 é¢†åŸŸæ¨¡å‹è®¾è®¡

```typescript
// src/domain/models/document.ts

export class DocumentModel {
  id: string;
  version: number;
  title: string;
  pages: Page[];
  grids: Map<string, Grid>;
  
  constructor(data: DocumentData) {
    this.id = data.id;
    this.version = data.version;
    this.title = data.title;
    this.pages = data.pages.map(p => new Page(p));
    this.grids = new Map();
  }
  
  /**
   * åº”ç”¨æ“ä½œ
   */
  applyOperation(operation: Operation): void {
    switch (operation.type) {
      case 'SLATE_INSERT_TEXT':
        this.applySlateInsertText(operation);
        break;
      case 'BULK_MODIFY_ROW_VALUE':
        this.applyBulkModifyRowValue(operation);
        break;
      // ... å…¶ä»–æ“ä½œç±»å‹
    }
    
    this.version = operation.version;
  }
  
  private applySlateInsertText(operation: InsertTextOperation): void {
    const page = this.pages.find(p => p.canvasId === operation.canvasId);
    if (!page) return;
    
    // åº”ç”¨åˆ° Slate
    page.canvas.applyOperation(operation);
  }
}

// src/domain/models/grid.ts

export class Grid {
  id: string;
  name: string;
  columns: ColumnCollection;
  rows: RowCollection;
  cellStorage: CellStorage;
  
  constructor(data: GridData) {
    this.id = data.id;
    this.name = data.name;
    this.columns = new ColumnCollection(data.columns);
    this.rows = new RowCollection(data.rows);
    this.cellStorage = new CellStorage(this);
  }
  
  /**
   * è·å–å•å…ƒæ ¼å€¼
   */
  getCellValue(rowId: string, columnId: string): CellValue | null {
    return this.cellStorage.getValue(rowId, columnId);
  }
  
  /**
   * è®¾ç½®å•å…ƒæ ¼å€¼
   */
  setCellValue(rowId: string, columnId: string, value: any): void {
    this.cellStorage.setValue(rowId, columnId, value);
  }
}
```

### 4.2 IndexedDB å­˜å‚¨

```bash
npm install dexie
```

```typescript
// src/infrastructure/storage/database.ts
import Dexie, { Table } from 'dexie';

interface DocumentRecord {
  id: string;
  version: number;
  data: any;
  updatedAt: number;
}

interface OperationRecord {
  opId: string;
  documentId: string;
  operation: Operation;
  timestamp: number;
}

class CodaDatabase extends Dexie {
  documents!: Table<DocumentRecord, string>;
  operations!: Table<OperationRecord, string>;
  
  constructor() {
    super('CodaDB');
    
    this.version(1).stores({
      documents: 'id, version, updatedAt',
      operations: 'opId, documentId, timestamp'
    });
  }
}

export const db = new CodaDatabase();

/**
 * æ–‡æ¡£ä»“å‚¨
 */
export class DocumentRepository {
  /**
   * ä¿å­˜æ–‡æ¡£
   */
  async save(document: DocumentModel): Promise<void> {
    await db.documents.put({
      id: document.id,
      version: document.version,
      data: this.serialize(document),
      updatedAt: Date.now()
    });
  }
  
  /**
   * åŠ è½½æ–‡æ¡£
   */
  async load(documentId: string): Promise<DocumentModel | null> {
    const record = await db.documents.get(documentId);
    
    if (!record) return null;
    
    return this.deserialize(record.data);
  }
  
  /**
   * åºåˆ—åŒ–
   */
  private serialize(document: DocumentModel): any {
    return {
      id: document.id,
      version: document.version,
      title: document.title,
      pages: document.pages.map(p => ({
        id: p.id,
        name: p.name,
        canvas: this.serializeCanvas(p.canvas)
      }))
      // ... æ›´å¤šå­—æ®µ
    };
  }
  
  /**
   * ååºåˆ—åŒ–
   */
  private deserialize(data: any): DocumentModel {
    return new DocumentModel(data);
  }
}
```

### 4.3 çŠ¶æ€ç®¡ç†

```bash
npm install zustand immer
```

```typescript
// src/application/stores/documentStore.ts
import create from 'zustand';
import { immer } from 'zustand/middleware/immer';

interface DocumentState {
  document: DocumentModel | null;
  isLoading: boolean;
  error: Error | null;
  
  // Actions
  loadDocument: (id: string) => Promise<void>;
  applyOperation: (operation: Operation) => void;
  updateCellValue: (gridId: string, rowId: string, columnId: string, value: any) => void;
}

export const useDocumentStore = create<DocumentState>()(
  immer((set, get) => ({
    document: null,
    isLoading: false,
    error: null,
    
    loadDocument: async (id: string) => {
      set({ isLoading: true, error: null });
      
      try {
        // ä»ä»“å‚¨åŠ è½½
        const repository = new DocumentRepository();
        const document = await repository.load(id);
        
        if (!document) {
          throw new Error('Document not found');
        }
        
        set({ document, isLoading: false });
      } catch (error) {
        set({ error: error as Error, isLoading: false });
      }
    },
    
    applyOperation: (operation: Operation) => {
      set((state) => {
        if (!state.document) return;
        
        state.document.applyOperation(operation);
      });
    },
    
    updateCellValue: (gridId, rowId, columnId, value) => {
      set((state) => {
        if (!state.document) return;
        
        const grid = state.document.grids.get(gridId);
        if (!grid) return;
        
        grid.setCellValue(rowId, columnId, value);
      });
    }
  }))
);
```

---

## 5. ååŒå±‚å®ç°æ–¹æ¡ˆ

### 5.1 WebSocket å®¢æˆ·ç«¯

```bash
npm install socket.io-client
```

```typescript
// src/infrastructure/websocket/client.ts
import { io, Socket } from 'socket.io-client';

export class WebSocketClient {
  private socket: Socket;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 10;
  
  constructor(private url: string) {
    this.socket = io(url, {
      transports: ['websocket'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: this.maxReconnectAttempts
    });
    
    this.setupEventListeners();
  }
  
  private setupEventListeners(): void {
    this.socket.on('connect', () => {
      console.log('âœ… Connected to server');
      this.reconnectAttempts = 0;
    });
    
    this.socket.on('disconnect', (reason) => {
      console.log('ğŸ”Œ Disconnected:', reason);
    });
    
    this.socket.on('reconnect_attempt', () => {
      this.reconnectAttempts++;
      console.log(`ğŸ”„ Reconnect attempt ${this.reconnectAttempts}`);
    });
    
    this.socket.on('error', (error) => {
      console.error('âŒ Socket error:', error);
    });
  }
  
  /**
   * è®¢é˜…æ–‡æ¡£
   */
  async subscribe(documentId: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.socket.emit('subscribe', { documentId }, (ack) => {
        if (ack.success) {
          resolve();
        } else {
          reject(new Error(ack.error));
        }
      });
    });
  }
  
  /**
   * å‘é€æ“ä½œ
   */
  async sendOperation(operation: Operation): Promise<void> {
    return new Promise((resolve, reject) => {
      this.socket.emit('operation', operation, (ack) => {
        if (ack.success) {
          resolve();
        } else {
          reject(new Error(ack.error));
        }
      });
    });
  }
  
  /**
   * ç›‘å¬æ“ä½œ
   */
  onOperation(handler: (operation: Operation) => void): void {
    this.socket.on('operation', handler);
  }
  
  /**
   * æ–­å¼€è¿æ¥
   */
  disconnect(): void {
    this.socket.disconnect();
  }
}
```

### 5.2 OT ç®—æ³•å®ç°

```typescript
// src/domain/models/ot.ts

/**
 * OT è½¬æ¢å¼•æ“
 */
export class OTEngine {
  /**
   * è½¬æ¢ä¸¤ä¸ªæ“ä½œ
   */
  transform(
    clientOp: Operation,
    serverOp: Operation
  ): [Operation, Operation] {
    if (clientOp.type === 'INSERT_TEXT' && serverOp.type === 'INSERT_TEXT') {
      return this.transformInsertVsInsert(
        clientOp as InsertTextOp,
        serverOp as InsertTextOp
      );
    }
    
    if (clientOp.type === 'INSERT_TEXT' && serverOp.type === 'REMOVE_TEXT') {
      return this.transformInsertVsRemove(
        clientOp as InsertTextOp,
        serverOp as RemoveTextOp
      );
    }
    
    // ... å…¶ä»–ç»„åˆ
    
    return [clientOp, serverOp];
  }
  
  /**
   * æ’å…¥ vs æ’å…¥
   */
  private transformInsertVsInsert(
    clientOp: InsertTextOp,
    serverOp: InsertTextOp
  ): [InsertTextOp, InsertTextOp] {
    const { offset: clientOffset, text: clientText } = clientOp;
    const { offset: serverOffset, text: serverText } = serverOp;
    
    if (clientOffset < serverOffset) {
      return [
        clientOp,
        { ...serverOp, offset: serverOffset + clientText.length }
      ];
    } else if (clientOffset > serverOffset) {
      return [
        { ...clientOp, offset: clientOffset + serverText.length },
        serverOp
      ];
    } else {
      // åŒä½ç½®ï¼šæŒ‰ userId æ’åº
      if (clientOp.userId < serverOp.userId) {
        return [
          clientOp,
          { ...serverOp, offset: serverOffset + clientText.length }
        ];
      } else {
        return [
          { ...clientOp, offset: clientOffset + serverText.length },
          serverOp
        ];
      }
    }
  }
  
  /**
   * æ’å…¥ vs åˆ é™¤
   */
  private transformInsertVsRemove(
    clientOp: InsertTextOp,
    serverOp: RemoveTextOp
  ): [InsertTextOp, RemoveTextOp] {
    const { offset: insertOffset, text } = clientOp;
    const { offset: removeOffset, length } = serverOp;
    const removeEnd = removeOffset + length;
    
    if (insertOffset <= removeOffset) {
      return [
        clientOp,
        { ...serverOp, offset: removeOffset + text.length }
      ];
    } else if (insertOffset >= removeEnd) {
      return [
        { ...clientOp, offset: insertOffset - length },
        serverOp
      ];
    } else {
      return [
        { ...clientOp, offset: removeOffset },
        serverOp
      ];
    }
  }
}
```

### 5.3 ååŒæœåŠ¡

```typescript
// src/application/services/collaborationService.ts

export class CollaborationService {
  private wsClient: WebSocketClient;
  private uncommittedLog: UncommittedLog;
  private otEngine: OTEngine;
  
  constructor(
    private documentStore: DocumentStore
  ) {
    this.wsClient = new WebSocketClient(WS_URL);
    this.uncommittedLog = new UncommittedLog();
    this.otEngine = new OTEngine();
    
    this.setupListeners();
  }
  
  private setupListeners(): void {
    this.wsClient.onOperation((operation) => {
      this.handleRemoteOperation(operation);
    });
  }
  
  /**
   * å‘é€æœ¬åœ°æ“ä½œ
   */
  async sendOperation(operation: Operation): Promise<void> {
    // æ·»åŠ åˆ°æœªæäº¤æ—¥å¿—
    this.uncommittedLog.add(operation);
    
    // ä¹è§‚åº”ç”¨åˆ°æœ¬åœ°
    this.documentStore.applyOperation(operation);
    
    // å‘é€åˆ°æœåŠ¡å™¨
    try {
      await this.wsClient.sendOperation(operation);
    } catch (error) {
      console.error('Failed to send operation:', error);
      // æ“ä½œç•™åœ¨æœªæäº¤æ—¥å¿—ï¼Œç¨åé‡è¯•
    }
  }
  
  /**
   * å¤„ç†è¿œç¨‹æ“ä½œ
   */
  private async handleRemoteOperation(operation: Operation): Promise<void> {
    // æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±çš„æ“ä½œï¼ˆSelf-ACKï¼‰
    const localOp = this.uncommittedLog.findByOpId(operation.opId);
    
    if (localOp) {
      // ä»æœªæäº¤æ—¥å¿—ç§»é™¤
      this.uncommittedLog.remove(operation.opId);
      return;
    }
    
    // ä»–äººçš„æ“ä½œï¼šOT è½¬æ¢
    const uncommitted = this.uncommittedLog.getAll();
    
    let transformedOp = operation;
    
    for (const uncommittedOp of uncommitted) {
      const [transformedUncommitted, transformedRemote] = 
        this.otEngine.transform(uncommittedOp, transformedOp);
      
      // æ›´æ–°æœªæäº¤æ“ä½œ
      this.uncommittedLog.update(uncommittedOp.opId, transformedUncommitted);
      
      transformedOp = transformedRemote;
    }
    
    // åº”ç”¨è½¬æ¢åçš„æ“ä½œ
    this.documentStore.applyOperation(transformedOp);
  }
}
```

---

## 6. å…¬å¼å±‚å®ç°æ–¹æ¡ˆ

### 6.1 å…¬å¼è§£æå™¨

```bash
npm install mathjs
```

```typescript
// src/domain/models/formula/parser.ts
import { parse as mathParse } from 'mathjs';

export class FormulaParser {
  /**
   * è§£æå…¬å¼
   */
  parse(formula: string): FormulaAST {
    // å»æ‰å¼€å¤´çš„ =
    const expression = formula.startsWith('=') 
      ? formula.slice(1) 
      : formula;
    
    try {
      // ä½¿ç”¨ math.js è§£æ
      const mathAST = mathParse(expression);
      
      // è½¬æ¢ä¸ºæˆ‘ä»¬çš„ AST æ ¼å¼
      return this.convertAST(mathAST);
    } catch (error) {
      throw new FormulaParseError(`Invalid formula: ${error.message}`);
    }
  }
  
  /**
   * è½¬æ¢ AST
   */
  private convertAST(mathAST: any): FormulaAST {
    switch (mathAST.type) {
      case 'FunctionNode':
        return {
          type: 'function',
          name: mathAST.fn.name,
          args: mathAST.args.map(arg => this.convertAST(arg))
        };
        
      case 'SymbolNode':
        return {
          type: 'symbol',
          name: mathAST.name
        };
        
      case 'ConstantNode':
        return {
          type: 'constant',
          value: mathAST.value
        };
        
      case 'OperatorNode':
        return {
          type: 'operator',
          operator: mathAST.fn,
          args: mathAST.args.map(arg => this.convertAST(arg))
        };
        
      default:
        throw new Error(`Unsupported node type: ${mathAST.type}`);
    }
  }
  
  /**
   * æå–ä¾èµ–
   */
  extractDependencies(ast: FormulaAST): CellReference[] {
    const deps: CellReference[] = [];
    
    this.traverse(ast, (node) => {
      if (node.type === 'symbol') {
        // è§£æå•å…ƒæ ¼å¼•ç”¨ï¼Œå¦‚ A1, Sheet1.A1
        const ref = this.parseCellReference(node.name);
        if (ref) {
          deps.push(ref);
        }
      }
    });
    
    return deps;
  }
  
  /**
   * éå† AST
   */
  private traverse(ast: FormulaAST, visitor: (node: FormulaAST) => void): void {
    visitor(ast);
    
    if ('args' in ast) {
      for (const arg of ast.args) {
        this.traverse(arg, visitor);
      }
    }
  }
}
```

### 6.2 å…¬å¼å¼•æ“ï¼ˆWeb Workerï¼‰

```typescript
// src/infrastructure/workers/formula.worker.ts

import { create, all } from 'mathjs';

const math = create(all);

// è‡ªå®šä¹‰å‡½æ•°
math.import({
  // æ–‡æœ¬å‡½æ•°
  CONCATENATE: (...args: any[]) => args.join(''),
  LEFT: (text: string, n: number) => text.slice(0, n),
  RIGHT: (text: string, n: number) => text.slice(-n),
  
  // é€»è¾‘å‡½æ•°
  IF: (condition: boolean, trueValue: any, falseValue: any) => 
    condition ? trueValue : falseValue,
  
  // èšåˆå‡½æ•°
  SUM: (...args: number[]) => args.reduce((sum, n) => sum + n, 0),
  AVERAGE: (...args: number[]) => {
    const sum = args.reduce((s, n) => s + n, 0);
    return sum / args.length;
  },
  
  // ... æ›´å¤šå‡½æ•°
});

/**
 * è®¡ç®—å…¬å¼
 */
self.addEventListener('message', async (event) => {
  const { id, type, ast, context } = event.data;
  
  if (type !== 'calculate') return;
  
  try {
    // æ„å»ºä½œç”¨åŸŸ
    const scope = buildScope(context);
    
    // æ‰§è¡Œå…¬å¼
    const result = math.evaluate(astToExpression(ast), scope);
    
    // è¿”å›ç»“æœ
    self.postMessage({
      id,
      result: {
        value: result,
        error: null
      }
    });
  } catch (error) {
    // è¿”å›é”™è¯¯
    self.postMessage({
      id,
      result: {
        value: null,
        error: error.message
      }
    });
  }
});

/**
 * æ„å»ºä½œç”¨åŸŸï¼ˆå˜é‡ä¸Šä¸‹æ–‡ï¼‰
 */
function buildScope(context: FormulaContext): Record<string, any> {
  const scope: Record<string, any> = {};
  
  // æ·»åŠ å•å…ƒæ ¼å¼•ç”¨
  for (const [name, value] of Object.entries(context.cells)) {
    scope[name] = value;
  }
  
  // æ·»åŠ ç‰¹æ®Šå˜é‡
  scope.thisRow = context.thisRow;
  scope.thisTable = context.thisTable;
  
  return scope;
}

/**
 * AST è½¬è¡¨è¾¾å¼å­—ç¬¦ä¸²
 */
function astToExpression(ast: FormulaAST): string {
  switch (ast.type) {
    case 'function':
      const args = ast.args.map(astToExpression).join(', ');
      return `${ast.name}(${args})`;
      
    case 'symbol':
      return ast.name;
      
    case 'constant':
      return typeof ast.value === 'string' 
        ? `"${ast.value}"` 
        : String(ast.value);
      
    case 'operator':
      const [left, right] = ast.args.map(astToExpression);
      return `(${left} ${ast.operator} ${right})`;
      
    default:
      throw new Error(`Unknown AST type: ${ast.type}`);
  }
}
```

### 6.3 ä¾èµ–å›¾ç®¡ç†

```typescript
// src/domain/models/formula/dependencyGraph.ts

export class DependencyGraph {
  // å‰å‘ä¾èµ–ï¼šA ä¾èµ–è°
  private forwardDeps = new Map<string, Set<string>>();
  
  // åå‘ä¾èµ–ï¼šè°ä¾èµ– A
  private backDeps = new Map<string, Set<string>>();
  
  /**
   * æ·»åŠ ä¾èµ–ï¼šfrom ä¾èµ– to
   */
  addDependency(from: CellReference, to: CellReference): void {
    const fromKey = this.refToKey(from);
    const toKey = this.refToKey(to);
    
    // å‰å‘ä¾èµ–
    if (!this.forwardDeps.has(fromKey)) {
      this.forwardDeps.set(fromKey, new Set());
    }
    this.forwardDeps.get(fromKey)!.add(toKey);
    
    // åå‘ä¾èµ–
    if (!this.backDeps.has(toKey)) {
      this.backDeps.set(toKey, new Set());
    }
    this.backDeps.get(toKey)!.add(fromKey);
  }
  
  /**
   * ç§»é™¤ä¾èµ–
   */
  removeDependency(from: CellReference, to: CellReference): void {
    const fromKey = this.refToKey(from);
    const toKey = this.refToKey(to);
    
    this.forwardDeps.get(fromKey)?.delete(toKey);
    this.backDeps.get(toKey)?.delete(fromKey);
  }
  
  /**
   * è·å–ä¾èµ–è€…ï¼ˆè°ä¾èµ–è¿™ä¸ªå•å…ƒæ ¼ï¼‰
   */
  getDependents(ref: CellReference): CellReference[] {
    const key = this.refToKey(ref);
    const dependentKeys = this.backDeps.get(key) || new Set();
    
    return Array.from(dependentKeys).map(k => this.keyToRef(k));
  }
  
  /**
   * è·å–ä¾èµ–é¡¹ï¼ˆè¿™ä¸ªå•å…ƒæ ¼ä¾èµ–è°ï¼‰
   */
  getDependencies(ref: CellReference): CellReference[] {
    const key = this.refToKey(ref);
    const dependencyKeys = this.forwardDeps.get(key) || new Set();
    
    return Array.from(dependencyKeys).map(k => this.keyToRef(k));
  }
  
  /**
   * æ£€æµ‹å¾ªç¯ä¾èµ–
   */
  hasCycle(ref: CellReference): boolean {
    const visited = new Set<string>();
    const stack = new Set<string>();
    
    const dfs = (key: string): boolean => {
      if (stack.has(key)) return true; // å‘ç°ç¯
      if (visited.has(key)) return false;
      
      visited.add(key);
      stack.add(key);
      
      const deps = this.forwardDeps.get(key) || new Set();
      for (const dep of deps) {
        if (dfs(dep)) return true;
      }
      
      stack.delete(key);
      return false;
    };
    
    return dfs(this.refToKey(ref));
  }
  
  private refToKey(ref: CellReference): string {
    return `${ref.gridId}:${ref.columnId}:${ref.rowId || '*'}`;
  }
  
  private keyToRef(key: string): CellReference {
    const [gridId, columnId, rowId] = key.split(':');
    return {
      gridId,
      columnId,
      rowId: rowId === '*' ? undefined : rowId
    };
  }
}
```

---

## 7. å¼€å‘è·¯çº¿å›¾

### Phase 1: MVPï¼ˆ3-4 ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šå•äººä½¿ç”¨çš„æ–‡æ¡£ç¼–è¾‘å™¨

- âœ… Week 1-2: é¡¹ç›®æ­å»ºã€åŸºç¡€æ¶æ„
  - æŠ€æœ¯é€‰å‹ç¡®å®š
  - å¼€å‘ç¯å¢ƒé…ç½®
  - CI/CD æµç¨‹
  
- âœ… Week 3-6: å¯Œæ–‡æœ¬ç¼–è¾‘å™¨
  - Slate é›†æˆ
  - åŸºç¡€ Block ç±»å‹ï¼ˆæ®µè½ã€æ ‡é¢˜ã€åˆ—è¡¨ï¼‰
  - æ–‡æœ¬æ ¼å¼åŒ–ï¼ˆç²—ä½“ã€æ–œä½“ã€ä¸‹åˆ’çº¿ï¼‰
  - é”®ç›˜å¿«æ·é”®
  
- âœ… Week 7-10: è¡¨æ ¼ç³»ç»Ÿ
  - Grid æ•°æ®æ¨¡å‹
  - åˆ—ç±»å‹ï¼ˆæ–‡æœ¬ã€æ•°å­—ã€æ—¥æœŸã€é€‰æ‹©ï¼‰
  - è¡Œæ“ä½œï¼ˆæ·»åŠ ã€åˆ é™¤ã€æ’åºï¼‰
  - åˆ—æ“ä½œï¼ˆæ·»åŠ ã€åˆ é™¤ã€è°ƒæ•´å®½åº¦ï¼‰
  
- âœ… Week 11-14: æœ¬åœ°å­˜å‚¨
  - IndexedDB é›†æˆ
  - æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–
  - è‡ªåŠ¨ä¿å­˜
  - ç‰ˆæœ¬å†å²
  
- âœ… Week 15-16: ä¼˜åŒ–ä¸æµ‹è¯•
  - æ€§èƒ½ä¼˜åŒ–
  - Bug ä¿®å¤
  - ç”¨æˆ·æµ‹è¯•

### Phase 2: ååŒç¼–è¾‘ï¼ˆ2-3 ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šå¤šäººå®æ—¶åä½œ

- âœ… Week 1-3: åç«¯æœåŠ¡
  - WebSocket æœåŠ¡å™¨
  - ç”¨æˆ·è®¤è¯
  - æ–‡æ¡£æŒä¹…åŒ–
  
- âœ… Week 4-6: OT ç®—æ³•
  - OT å¼•æ“å®ç°
  - æ“ä½œè½¬æ¢é€»è¾‘
  - å†²çªè§£å†³
  
- âœ… Week 7-9: ååŒåŠŸèƒ½
  - å®æ—¶å…‰æ ‡æ˜¾ç¤º
  - ç”¨æˆ·åœ¨çº¿çŠ¶æ€
  - æ“ä½œåŒæ­¥
  
- âœ… Week 10-12: ç¦»çº¿æ”¯æŒ
  - æœªæäº¤æ“ä½œç®¡ç†
  - è‡ªåŠ¨é‡è¿
  - ç‰ˆæœ¬å¯¹é½

### Phase 3: å…¬å¼å¼•æ“ï¼ˆ2-3 ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šå¼ºå¤§çš„è®¡ç®—èƒ½åŠ›

- âœ… Week 1-3: å…¬å¼è§£æ
  - è¯æ³•åˆ†æ
  - è¯­æ³•åˆ†æ
  - AST ç”Ÿæˆ
  
- âœ… Week 4-6: å…¬å¼æ‰§è¡Œ
  - Web Worker é›†æˆ
  - å†…ç½®å‡½æ•°åº“
  - è‡ªå®šä¹‰å‡½æ•°
  
- âœ… Week 7-9: ä¾èµ–è¿½è¸ª
  - ä¾èµ–å›¾æ„å»º
  - å¤±æ•ˆä¼ æ’­
  - å¢é‡é‡ç®—
  
- âœ… Week 10-12: é«˜çº§ç‰¹æ€§
  - å¾ªç¯ä¾èµ–æ£€æµ‹
  - å…¬å¼è°ƒè¯•
  - æ€§èƒ½ä¼˜åŒ–

### Phase 4: é«˜çº§åŠŸèƒ½ï¼ˆ3-4 ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šä¸°å¯Œçš„ç”Ÿäº§åŠ›å·¥å…·

- è§†å›¾ç³»ç»Ÿï¼ˆå¡ç‰‡è§†å›¾ã€çœ‹æ¿è§†å›¾ã€æ—¥å†è§†å›¾ï¼‰
- è‡ªåŠ¨åŒ–ï¼ˆè§¦å‘å™¨ã€å·¥ä½œæµï¼‰
- é›†æˆï¼ˆAPIã€Webhookã€ç¬¬ä¸‰æ–¹æœåŠ¡ï¼‰
- ç§»åŠ¨ç«¯é€‚é…
- æƒé™ç®¡ç†

---

## 8. æŠ€æœ¯éš¾ç‚¹ä¸è§£å†³æ–¹æ¡ˆ

### 8.1 å¯Œæ–‡æœ¬ç¼–è¾‘ä¸€è‡´æ€§

**éš¾ç‚¹**ï¼šSlate çš„ normalization å¯èƒ½å¯¼è‡´é€‰åŒºè·³è·ƒ

**è§£å†³æ–¹æ¡ˆ**ï¼š
```typescript
// ä½¿ç”¨ withoutNormalizing æš‚åœå½’ä¸€åŒ–
Editor.withoutNormalizing(editor, () => {
  // æ‰¹é‡æ“ä½œ
  Transforms.insertNodes(editor, nodes);
  Transforms.setNodes(editor, props);
});
// æ‰¹é‡å®Œæˆåä¸€æ¬¡æ€§å½’ä¸€åŒ–
```

### 8.2 å¤§è¡¨æ ¼æ€§èƒ½

**éš¾ç‚¹**ï¼šä¸‡è¡Œçº§åˆ«çš„è¡¨æ ¼æ¸²æŸ“å¡é¡¿

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. è™šæ‹ŸåŒ–æ¸²æŸ“ï¼ˆreact-windowï¼‰
2. æ‡’åŠ è½½æ•°æ®ï¼ˆåˆ†é¡µè¯·æ±‚ï¼‰
3. å•å…ƒæ ¼å€¼ç¼“å­˜
4. debounce è¾“å…¥äº‹ä»¶

### 8.3 OT å†²çªå¤æ‚

**éš¾ç‚¹**ï¼šå¤šç”¨æˆ·å¹¶å‘ç¼–è¾‘çš„æ“ä½œè½¬æ¢

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. æ˜ç¡®å®šä¹‰æ‰€æœ‰æ“ä½œç±»å‹
2. ä¸ºæ¯å¯¹æ“ä½œç±»å‹å®ç°è½¬æ¢å‡½æ•°
3. å•å…ƒæµ‹è¯•è¦†ç›–æ‰€æœ‰ç»„åˆ
4. æœåŠ¡ç«¯æœ€ç»ˆè£å†³ï¼ˆLWWï¼‰

### 8.4 å…¬å¼å¾ªç¯ä¾èµ–

**éš¾ç‚¹**ï¼šæ£€æµ‹å’Œå¤„ç†å¾ªç¯å¼•ç”¨

**è§£å†³æ–¹æ¡ˆ**ï¼š
```typescript
// DFS æ£€æµ‹ç¯
function hasCycle(startRef: CellReference): boolean {
  const visited = new Set();
  const stack = new Set();
  
  function dfs(ref: string): boolean {
    if (stack.has(ref)) return true;
    if (visited.has(ref)) return false;
    
    stack.add(ref);
    visited.add(ref);
    
    const deps = dependencyGraph.getDependencies(ref);
    for (const dep of deps) {
      if (dfs(dep)) return true;
    }
    
    stack.delete(ref);
    return false;
  }
  
  return dfs(refToKey(startRef));
}
```

### 8.5 ç¦»çº¿åŒæ­¥å†²çª

**éš¾ç‚¹**ï¼šé•¿æ—¶é—´ç¦»çº¿åçš„æ•°æ®åˆå¹¶

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. ä½¿ç”¨æ“ä½œæ—¥å¿—è€ŒéçŠ¶æ€å¿«ç…§
2. ç‰ˆæœ¬å‘é‡è¿½è¸ªåˆ†æ”¯
3. ä¸‰å‘åˆå¹¶ç®—æ³•
4. å†²çªæ ‡è®°å’Œäººå·¥è§£å†³

---

## æ€»ç»“

æ„å»ºä¸€ä¸ªç±» Coda çš„äº§å“æ˜¯ä¸€ä¸ªå¤æ‚çš„ç³»ç»Ÿå·¥ç¨‹ï¼Œéœ€è¦ï¼š

1. **æ‰å®çš„å‰ç«¯åŸºç¡€**ï¼šReactã€TypeScriptã€Slate.js
2. **åˆ†å¸ƒå¼ç³»ç»ŸçŸ¥è¯†**ï¼šOTã€CRDTã€æœ€ç»ˆä¸€è‡´æ€§
3. **æ€§èƒ½ä¼˜åŒ–ç»éªŒ**ï¼šè™šæ‹ŸåŒ–ã€ç¼“å­˜ã€Web Workers
4. **åç«¯å¼€å‘èƒ½åŠ›**ï¼šWebSocketã€æ•°æ®åº“ã€API è®¾è®¡
5. **äº§å“æ€ç»´**ï¼šç”¨æˆ·ä½“éªŒã€åŠŸèƒ½ä¼˜å…ˆçº§ã€è¿­ä»£ç­–ç•¥

**å»ºè®®çš„èµ·æ­¥æ–¹å¼**ï¼š

1. **ä»å°åšèµ·**ï¼šå…ˆåšä¸€ä¸ªå•äººæ–‡æ¡£ç¼–è¾‘å™¨
2. **è¿­ä»£å¼€å‘**ï¼šé€æ­¥æ·»åŠ ååŒã€å…¬å¼ç­‰é«˜çº§åŠŸèƒ½
3. **æµ‹è¯•é©±åŠ¨**ï¼šTDD ä¿è¯è´¨é‡ï¼Œç‰¹åˆ«æ˜¯ OT ç®—æ³•
4. **å‚è€ƒå¼€æº**ï¼šå­¦ä¹  Slateã€Yjsã€Automerge ç­‰é¡¹ç›®
5. **æŒç»­ä¼˜åŒ–**ï¼šæ€§èƒ½å’Œç”¨æˆ·ä½“éªŒæ°¸è¿œæœ‰æå‡ç©ºé—´

Good luck with your Coda-like product! ğŸš€
